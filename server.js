const express = require('express');
const { Client, LocalAuth, MessageMedia, NoAuth } = require('whatsapp-web.js');
const multer = require('multer');
const fs = require('fs');
const path = require('path');
const axios = require('axios');
const mime = require('mime-types');
const swaggerUi = require('swagger-ui-express');
const YAML = require('yamljs');
const cors = require('cors');

/*
 * Whatsapp WebJS API server
 *
 * This server exposes a REST API on top of the whatsapp‑web.js client library. It
 * is designed to manage up to MAX_SESSIONS concurrent sessions and provides
 * endpoints for common tasks such as sending messages, receiving media,
 * listing chats and contacts, and downloading attachments. Incoming
 * messages can optionally be forwarded to a user‑provided webhook URL with
 * rich metadata and downloadable media. The API contract is documented via
 * an OpenAPI specification (openapi.yaml) and rendered at /api-docs.
 */

const MAX_SESSIONS = 5;

// Paths where session data and downloaded media will be stored. The
// authentication files generated by whatsapp‑web.js (browser cookies, etc.)
// live under `.wwebjs_auth` and are keyed by the session identifier. Media
// files downloaded from incoming messages are saved under `media` so they
// can be served back to clients or forwarded to webhooks.
const DATA_DIR = path.join(__dirname, '.wwebjs_auth');
const MEDIA_DIR = path.join(__dirname, 'media');

// Ensure required directories exist
for (const dir of [DATA_DIR, MEDIA_DIR]) {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
}

// In‑memory registry of active sessions. Each entry contains:
// {
//   id: string,
//   client: Client,
//   status: 'initializing' | 'qr' | 'authenticated' | 'ready' | 'disconnected' | 'failed',
//   qr: string | null,
//   webhook: string | null,
// }
const sessions = new Map();

// Express app
const app = express();
app.use(cors());
app.use(express.json({ limit: '25mb' }));
app.use(express.urlencoded({ extended: true, limit: '25mb' }));

// Configure Multer for handling single file uploads in memory. When sending
// media you can either POST a base64 encoded string (data URI) or attach a
// binary file using multipart/form‑data under the `file` field.
const upload = multer({ storage: multer.memoryStorage() });

// Serve downloaded media files statically. Files under /media can be
// retrieved via GET /media/<filename> and will return the binary contents.
app.use('/media', express.static(MEDIA_DIR));

// Load the OpenAPI specification and mount the Swagger UI at /api-docs.
const openApiPath = path.join(__dirname, 'openapi.yaml');
let openApiDocument;
try {
  openApiDocument = YAML.load(openApiPath);
} catch (err) {
  console.warn('Unable to load openapi.yaml:', err.message);
  openApiDocument = { openapi: '3.0.0', info: { title: 'WhatsApp API', version: '1.0.0' } };
}
app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(openApiDocument));

/**
 * Normalize a WhatsApp identifier. The underlying library expects chat and
 * contact identifiers to include the domain suffix (e.g. 1234567890@c.us for
 * individual chats and 1234567890-123456@g.us for groups). This helper
 * appends @c.us if a plain phone number is provided by the caller.
 *
 * @param {string} id
 * @returns {string}
 */
function normalizeId(id) {
  if (id.includes('@')) return id;
  // assume direct chat
  return `${id}@c.us`;
}

/**
 * Utility to save a base64 encoded media payload to disk. Returns the
 * filename relative to MEDIA_DIR. When a filename is provided in the
 * MessageMedia instance it will be used; otherwise one is generated from
 * the MIME type and a timestamp.
 *
 * @param {Object} media
 * @param {string} sessionId
 * @returns {string}
 */
function saveMediaToDisk(media, sessionId) {
  const buffer = Buffer.from(media.data, 'base64');
  const ext = mime.extension(media.mimetype) || 'bin';
  const safeName = media.filename ? media.filename.replace(/[^a-zA-Z0-9_.-]/g, '_') : `${Date.now()}_${sessionId}.${ext}`;
  const fileName = `${safeName}`;
  const fullPath = path.join(MEDIA_DIR, fileName);
  fs.writeFileSync(fullPath, buffer);
  return fileName;
}

/**
 * Serializes a whatsapp-web.js Message object into a plain JSON payload. If
 * the message contains media and the download flag is true, the media will
 * be downloaded and stored on disk. The returned object includes the file
 * name and a URL path that can be fetched via the /media endpoint.
 *
 * @param {Object} message
 * @param {boolean} downloadMedia
 * @param {string} sessionId
 * @returns {Promise<Object>}
 */
async function serializeMessage(message, downloadMediaFlag, sessionId) {
  const base = {
    id: message.id._serialized || message.id.id || null,
    from: message.from,
    to: message.to,
    body: message.body,
    type: message.type,
    timestamp: message.timestamp,
    fromMe: message.fromMe,
    hasMedia: message.hasMedia,
  };
  // include quoted message id if present
  if (message.hasQuotedMsg) {
    try {
      const quoted = await message.getQuotedMessage();
      base.quotedId = quoted.id._serialized || quoted.id.id;
    } catch (_) {
      // ignore
    }
  }
  if (downloadMediaFlag && message.hasMedia) {
    try {
      const media = await message.downloadMedia();
      if (media) {
        const fileName = saveMediaToDisk(media, sessionId);
        base.media = {
          filename: media.filename || fileName,
          mimetype: media.mimetype,
          filesize: Buffer.from(media.data, 'base64').length,
          url: `/media/${fileName}`,
        };
      }
    } catch (err) {
      console.error('Failed to download media:', err);
    }
  }
  return base;
}

/**
 * Internal helper to wire up event listeners on a new session. Responsible
 * for updating status, caching the latest QR code and forwarding incoming
 * messages to the configured webhook.
 *
 * @param {Object} session
 */
function wireSessionEvents(session) {
  const { client, id } = session;
  client.on('qr', (qr) => {
    session.status = 'qr';
    session.qr = qr;
  });
  client.on('authenticated', () => {
    session.status = 'authenticated';
  });
  client.on('ready', () => {
    session.status = 'ready';
    session.qr = null;
  });
  client.on('auth_failure', (msg) => {
    session.status = 'failed';
    console.error(`Authentication failed for session ${id}: ${msg}`);
  });
  client.on('disconnected', (reason) => {
    session.status = 'disconnected';
    console.warn(`Client ${id} disconnected:`, reason);
    // Do not remove auth files to allow reconnection; the client will
    // automatically attempt to reconnect. If you wish to fully remove the
    // session call DELETE /sessions/:id.
  });
  client.on('message', async (message) => {
    // On every incoming message, forward it to the session's webhook if one
    // is configured. Media will be downloaded if possible.
    if (!session.webhook) return;
    try {
      const payload = await serializeMessage(message, true, id);
      payload.sessionId = id;
      // Include chat information (name and isGroup flag) for convenience
      try {
        const chat = await message.getChat();
        payload.chat = {
          id: chat.id._serialized || chat.id,
          name: chat.name,
          isGroup: chat.isGroup,
        };
      } catch (_) {
        // ignore
      }
      await axios.post(session.webhook, payload, { timeout: 10000 });
    } catch (err) {
      console.error('Error forwarding message to webhook', session.webhook, err.message);
    }
  });
}

/**
 * Creates or returns an existing session. If the session already exists it
 * returns the cached instance; otherwise it spawns a new whatsapp-web.js
 * client, registers event listeners and starts initialization. If the
 * maximum number of sessions is exceeded the function will reject.
 *
 * @param {string} sessionId
 * @returns {Promise<Object>}
 */
async function createSession(sessionId) {
  if (sessions.has(sessionId)) {
    return sessions.get(sessionId);
  }
  if (sessions.size >= MAX_SESSIONS) {
    throw new Error(`Maximum number of sessions (${MAX_SESSIONS}) reached`);
  }
  // Create the client with a persistent LocalAuth strategy. Each session
  // gets its own directory under DATA_DIR, keyed by clientId. The headless
  // browser runs with a small set of flags to minimise resource usage.
  const client = new Client({
    puppeteer: {
      headless: true,
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage',
        '--disable-extensions',
        '--disable-gpu',
      ],
    },
    authStrategy: new LocalAuth({ dataPath: DATA_DIR, clientId: sessionId }),
  });
  const session = {
    id: sessionId,
    client,
    status: 'initializing',
    qr: null,
    webhook: null,
  };
  sessions.set(sessionId, session);
  wireSessionEvents(session);
  // Start initialization in background; do not await here so the API can
  // return immediately. Errors are logged on the client events.
  client.initialize().catch((err) => {
    session.status = 'failed';
    console.error('Error initializing client', err);
  });
  return session;
}

/**
 * Destroys a session, freeing browser resources and removing the session
 * from the registry. Authentication files on disk are also deleted so a
 * subsequent createSession call will require scanning a new QR code.
 *
 * @param {string} sessionId
 */
async function destroySession(sessionId) {
  const session = sessions.get(sessionId);
  if (!session) return;
  try {
    await session.client.destroy();
  } catch (err) {
    console.warn(`Error destroying client ${sessionId}:`, err.message);
  }
  sessions.delete(sessionId);
  // Remove auth directory for this client
  const clientDir = path.join(DATA_DIR, sessionId);
  if (fs.existsSync(clientDir)) {
    fs.rmSync(clientDir, { recursive: true, force: true });
  }
}

// -------------- API ENDPOINTS -----------------

// Health check
app.get('/', (req, res) => {
  res.json({ status: 'ok', message: 'WhatsApp WebJS API server running' });
});

// Create a new session. Body must contain { id } – a unique string. The
// response will include the session status and a hint to fetch the QR code.
app.post('/sessions', async (req, res) => {
  const { id } = req.body;
  if (!id || typeof id !== 'string') {
    return res.status(400).json({ error: 'Missing session id in request body' });
  }
  try {
    const session = await createSession(id);
    res.status(201).json({ id: session.id, status: session.status, qr: session.qr });
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
});

// List all sessions
app.get('/sessions', (req, res) => {
  const list = [];
  sessions.forEach((session) => {
    list.push({ id: session.id, status: session.status });
  });
  res.json(list);
});

// Get session info
app.get('/sessions/:id', (req, res) => {
  const session = sessions.get(req.params.id);
  if (!session) return res.status(404).json({ error: 'Session not found' });
  res.json({ id: session.id, status: session.status, qr: session.qr, webhook: session.webhook });
});

// Remove session
app.delete('/sessions/:id', async (req, res) => {
  const { id } = req.params;
  if (!sessions.has(id)) return res.status(404).json({ error: 'Session not found' });
  await destroySession(id);
  res.json({ status: 'deleted' });
});

// Set or clear the webhook URL for a session. A POST with { url: string }
// registers a webhook; a DELETE removes it. The webhook will receive
// serialized message payloads for all incoming messages.
app.post('/sessions/:id/webhook', (req, res) => {
  const session = sessions.get(req.params.id);
  if (!session) return res.status(404).json({ error: 'Session not found' });
  const { url } = req.body;
  if (!url || typeof url !== 'string') {
    return res.status(400).json({ error: 'Missing url in request body' });
  }
  session.webhook = url;
  res.json({ status: 'ok', webhook: url });
});

app.delete('/sessions/:id/webhook', (req, res) => {
  const session = sessions.get(req.params.id);
  if (!session) return res.status(404).json({ error: 'Session not found' });
  session.webhook = null;
  res.json({ status: 'ok' });
});

// Get current QR code for session. The QR string returned by whatsapp-web.js
// must be rendered by the client into a scannable QR code. When the QR
// expires or after authentication this endpoint will return null.
app.get('/sessions/:id/qr', (req, res) => {
  const session = sessions.get(req.params.id);
  if (!session) return res.status(404).json({ error: 'Session not found' });
  res.json({ qr: session.qr });
});

// List chats for a session
app.get('/sessions/:id/chats', async (req, res) => {
  const session = sessions.get(req.params.id);
  if (!session) return res.status(404).json({ error: 'Session not found' });
  if (session.status !== 'ready') return res.status(409).json({ error: 'Session not ready' });
  try {
    const chats = await session.client.getChats();
    const result = chats.map((chat) => ({
      id: chat.id._serialized || chat.id,
      name: chat.name,
      isGroup: chat.isGroup,
      unreadCount: chat.unreadCount,
    }));
    res.json(result);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Fetch messages from a chat. Supports optional query parameter `limit` to
// restrict the number of messages returned. Messages are ordered from
// newest to oldest.
app.get('/sessions/:id/chats/:chatId/messages', async (req, res) => {
  const session = sessions.get(req.params.id);
  if (!session) return res.status(404).json({ error: 'Session not found' });
  if (session.status !== 'ready') return res.status(409).json({ error: 'Session not ready' });
  const chatId = normalizeId(req.params.chatId);
  const limit = req.query.limit ? parseInt(req.query.limit, 10) : 50;
  try {
    const chat = await session.client.getChatById(chatId);
    const messages = await chat.fetchMessages({ limit });
    const result = [];
    for (const msg of messages.reverse()) {
      result.push(await serializeMessage(msg, false, session.id));
    }
    res.json(result);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Send a plain text message. Body: { to, message, options? }. The `to`
// parameter should be a phone number or chatId. The optional options
// property allows specifying mentions, quotedMessageId, etc. See
// https://docs.wwebjs.dev/Message.html#sendMessage for details.
app.post('/sessions/:id/messages', async (req, res) => {
  const session = sessions.get(req.params.id);
  if (!session) return res.status(404).json({ error: 'Session not found' });
  if (session.status !== 'ready') return res.status(409).json({ error: 'Session not ready' });
  const { to, message, options } = req.body;
  if (!to || !message) return res.status(400).json({ error: 'Missing to or message field' });
  const chatId = normalizeId(to);
  try {
    const msg = await session.client.sendMessage(chatId, message, options || {});
    res.json({ id: msg.id._serialized || msg.id.id, timestamp: msg.timestamp });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Send media. Accepts multipart/form‑data with a single file and fields
// `to` (required) and `caption` (optional). You may also send a JSON body
// containing { to, media: { mimetype, data, filename }, caption }. The
// media.data must be a base64 encoded string (without Data URI prefix).
app.post('/sessions/:id/media', upload.single('file'), async (req, res) => {
  const session = sessions.get(req.params.id);
  if (!session) return res.status(404).json({ error: 'Session not found' });
  if (session.status !== 'ready') return res.status(409).json({ error: 'Session not ready' });
  const { to, caption } = req.body;
  if (!to) return res.status(400).json({ error: 'Missing to field' });
  let media;
  try {
    if (req.file) {
      // Build MessageMedia from uploaded binary buffer
      const mimetype = req.file.mimetype;
      const base64Data = req.file.buffer.toString('base64');
      const filename = req.file.originalname;
      media = new MessageMedia(mimetype, base64Data, filename);
    } else if (req.body.media) {
      // Expect an object with mimetype, data and optionally filename
      const m = req.body.media;
      if (!m.mimetype || !m.data) {
        return res.status(400).json({ error: 'media object must include mimetype and data' });
      }
      media = new MessageMedia(m.mimetype, m.data, m.filename || undefined);
    } else {
      return res.status(400).json({ error: 'No media provided' });
    }
    const chatId = normalizeId(to);
    const msg = await session.client.sendMessage(chatId, media, { caption });
    res.json({ id: msg.id._serialized || msg.id.id, timestamp: msg.timestamp });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Download media from a given message. Returns JSON with filename,
// mimetype, filesize and a base64 encoded data property. Use the /media
// endpoint instead if you prefer streaming binary files. Note: If the
// message no longer exists in the client's cache or it never contained
// media this endpoint will return 404.
app.get('/sessions/:id/messages/:messageId/media', async (req, res) => {
  const session = sessions.get(req.params.id);
  if (!session) return res.status(404).json({ error: 'Session not found' });
  if (session.status !== 'ready') return res.status(409).json({ error: 'Session not ready' });
  try {
    const message = await session.client.getMessageById(req.params.messageId);
    if (!message) return res.status(404).json({ error: 'Message not found' });
    if (!message.hasMedia) return res.status(400).json({ error: 'Message has no media' });
    const media = await message.downloadMedia();
    res.json({
      filename: media.filename,
      mimetype: media.mimetype,
      filesize: Buffer.from(media.data, 'base64').length,
      data: media.data,
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// List contacts
app.get('/sessions/:id/contacts', async (req, res) => {
  const session = sessions.get(req.params.id);
  if (!session) return res.status(404).json({ error: 'Session not found' });
  if (session.status !== 'ready') return res.status(409).json({ error: 'Session not ready' });
  try {
    const contacts = await session.client.getContacts();
    const result = contacts.map((c) => ({
      id: c.id._serialized || c.id,
      name: c.name,
      number: c.number,
      isUser: c.isUser,
      isGroup: c.isGroup,
      isBusiness: c.isBusiness,
    }));
    res.json(result);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Get contact details, including profile picture URL (if available)
app.get('/sessions/:id/contacts/:contactId', async (req, res) => {
  const session = sessions.get(req.params.id);
  if (!session) return res.status(404).json({ error: 'Session not found' });
  if (session.status !== 'ready') return res.status(409).json({ error: 'Session not ready' });
  const contactId = normalizeId(req.params.contactId);
  try {
    const contact = await session.client.getContactById(contactId);
    const profilePicUrl = await contact.getProfilePicUrl().catch(() => null);
    res.json({
      id: contact.id._serialized || contact.id,
      name: contact.name,
      number: contact.number,
      pushname: contact.pushname,
      isBusiness: contact.isBusiness,
      isUser: contact.isUser,
      isGroup: contact.isGroup,
      about: await contact.getAbout().catch(() => null),
      profilePicUrl,
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Pin or unpin a message. Body: { messageId, pin: boolean, duration }
app.post('/sessions/:id/pin-message', async (req, res) => {
  const session = sessions.get(req.params.id);
  if (!session) return res.status(404).json({ error: 'Session not found' });
  if (session.status !== 'ready') return res.status(409).json({ error: 'Session not ready' });
  const { messageId, pin, duration } = req.body;
  if (!messageId) return res.status(400).json({ error: 'Missing messageId' });
  try {
    const message = await session.client.getMessageById(messageId);
    if (!message) return res.status(404).json({ error: 'Message not found' });
    let result;
    if (pin) {
      result = await message.pin(duration);
    } else {
      result = await message.unpin();
    }
    res.json({ pinned: result });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// React to a message. Body: { messageId, reaction }
app.post('/sessions/:id/react-message', async (req, res) => {
  const session = sessions.get(req.params.id);
  if (!session) return res.status(404).json({ error: 'Session not found' });
  if (session.status !== 'ready') return res.status(409).json({ error: 'Session not ready' });
  const { messageId, reaction } = req.body;
  if (!messageId || typeof reaction !== 'string') return res.status(400).json({ error: 'Missing messageId or reaction' });
  try {
    const message = await session.client.getMessageById(messageId);
    if (!message) return res.status(404).json({ error: 'Message not found' });
    await message.react(reaction);
    res.json({ status: 'ok' });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Update the current user status (about message). Body: { status }
app.post('/sessions/:id/status', async (req, res) => {
  const session = sessions.get(req.params.id);
  if (!session) return res.status(404).json({ error: 'Session not found' });
  if (session.status !== 'ready') return res.status(409).json({ error: 'Session not ready' });
  const { status } = req.body;
  if (typeof status !== 'string') return res.status(400).json({ error: 'Missing status text' });
  try {
    await session.client.setStatus(status);
    res.json({ status: 'ok' });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Forward a message to a different chat. Body: { messageId, to }
app.post('/sessions/:id/forward-message', async (req, res) => {
  const session = sessions.get(req.params.id);
  if (!session) return res.status(404).json({ error: 'Session not found' });
  if (session.status !== 'ready') return res.status(409).json({ error: 'Session not ready' });
  const { messageId, to } = req.body;
  if (!messageId || !to) return res.status(400).json({ error: 'Missing messageId or to' });
  try {
    const message = await session.client.getMessageById(messageId);
    if (!message) return res.status(404).json({ error: 'Message not found' });
    const chatId = normalizeId(to);
    await message.forward(chatId);
    res.json({ status: 'ok' });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Start the HTTP server
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`WhatsApp API server listening on port ${PORT}`);
});